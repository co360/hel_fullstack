{"ast":null,"code":"import { __assign } from 'tslib';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { getTypenameFromResult, argumentsObjectFromField, storeKeyNameFromField, isReference, isField } from '../../utilities/graphql/storeUtils.js';\nimport { canUseWeakMap } from '../../utilities/common/canUse.js';\nimport { KeyTrie } from 'optimism';\nimport { fieldNameFromStoreName, isFieldValueToBeMerged } from './helpers.js';\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction defaultDataIdFromObject(object) {\n  var __typename = object.__typename,\n      id = object.id,\n      _id = object._id;\n\n  if (typeof __typename === \"string\") {\n    if (id !== void 0) return __typename + \":\" + id;\n    if (_id !== void 0) return __typename + \":\" + _id;\n  }\n}\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.storageTrie = new KeyTrie(true);\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap,\n      policies: this\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n          fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : void 0;\n\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n          var incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n                read = incoming.read,\n                merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            if (typeof merge === \"function\") existing.merge = merge;\n          }\n\n          if (existing.read && existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 35) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      var subtypeSet = _this.getSubtypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    if (typename) {\n      return this.typePolicies[typename] || createIfMissing && (this.typePolicies[typename] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n    var policy = this.getTypePolicy(supertype, createIfMissing);\n\n    if (policy) {\n      return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n    }\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes) {\n      var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var subtypes = workQueue_1[i];\n\n        if (subtypes) {\n          if (subtypes.has(typename)) return true;\n          subtypes.forEach(function (subtype) {\n            var subsubtypes = _this.getSubtypeSet(subtype, false);\n\n            if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n              workQueue_1.push(subsubtypes);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.getStoreFieldName = function (typename, field, variables) {\n    var fieldName = field.name.value;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var args = argumentsObjectFromField(field, variables);\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: field,\n        variables: variables,\n        policies: this\n      };\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = storeKeyNameFromField(field, variables);\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (objectOrReference, nameOrField, context, typename) {\n    if (typename === void 0) {\n      typename = context.getFieldValue(objectOrReference, \"__typename\");\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(objectOrReference, 36) : invariant(objectOrReference, \"Must provide an object or Reference when calling Policies#readField\");\n    var policies = this;\n    var storeFieldName = typeof nameOrField === \"string\" ? nameOrField : policies.getStoreFieldName(typename, nameOrField, context.variables);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.getFieldValue(objectOrReference, storeFieldName);\n    var policy = policies.getFieldPolicy(typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var storage = policies.storageTrie.lookup(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName);\n      return read(existing, makeFieldFunctionOptions(policies, typename, objectOrReference, nameOrField, storage, context));\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n\n  Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n    var policies = this;\n\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var merge = policies.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n      var storage = storageKeys ? policies.storageTrie.lookupArray(storageKeys) : null;\n      incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(policies, incoming.__typename, null, field, storage, context));\n    }\n\n    if (incoming && typeof incoming === \"object\") {\n      if (isReference(incoming)) {\n        return incoming;\n      }\n\n      if (Array.isArray(incoming)) {\n        return incoming.map(function (item) {\n          return policies.applyMerges(void 0, item, context);\n        });\n      }\n\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        i_1[storeFieldName] = policies.applyMerges(context.getFieldValue(e_1, storeFieldName), i_1[storeFieldName], context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n      });\n    }\n\n    return incoming;\n  };\n\n  return Policies;\n}();\n\nfunction makeFieldFunctionOptions(policies, typename, objectOrReference, nameOrField, storage, context) {\n  var toReference = context.toReference,\n      getFieldValue = context.getFieldValue,\n      variables = context.variables;\n  var storeFieldName = typeof nameOrField === \"string\" ? nameOrField : policies.getStoreFieldName(typename, nameOrField, variables);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  return {\n    args: typeof nameOrField === \"string\" ? null : argumentsObjectFromField(nameOrField, variables),\n    field: typeof nameOrField === \"string\" ? null : nameOrField,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    policies: policies,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    readField: function (nameOrField, foreignObjOrRef) {\n      return policies.readField(foreignObjOrRef || objectOrReference, nameOrField, context);\n    },\n    mergeObjects: function (existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(37) : new InvariantError(\"Cannot automatically merge arrays\");\n      }\n\n      if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n        var eType = getFieldValue(existing, \"__typename\");\n        var iType = getFieldValue(incoming, \"__typename\");\n        var typesDiffer = eType && iType && eType !== iType;\n        var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n\n        if (typesDiffer || !canBeMerged(existing) || !canBeMerged(applied)) {\n          return applied;\n        }\n\n        return __assign(__assign({}, existing), applied);\n      }\n\n      return incoming;\n    }\n  };\n}\n\nfunction canBeMerged(obj) {\n  return !!(obj && typeof obj === \"object\" && !isReference(obj) && !Array.isArray(obj));\n}\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    var field = context.field;\n    var fieldName = field.name.value;\n    return args ? fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 38) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}\n\nexport { Policies, defaultDataIdFromObject };","map":{"version":3,"sources":["policies.js"],"names":[],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, } from '../../utilities/graphql/storeUtils';\nimport { canUseWeakMap } from '../../utilities/common/canUse';\nimport { fieldNameFromStoreName, isFieldValueToBeMerged, } from './helpers';\nvar hasOwn = Object.prototype.hasOwnProperty;\nexport function defaultDataIdFromObject(object) {\n    var __typename = object.__typename, id = object.id, _id = object._id;\n    if (typeof __typename === \"string\") {\n        if (id !== void 0)\n            return __typename + \":\" + id;\n        if (_id !== void 0)\n            return __typename + \":\" + _id;\n    }\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar Policies = (function () {\n    function Policies(config) {\n        if (config === void 0) { config = {}; }\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.storageTrie = new KeyTrie(true);\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n        var typename = selectionSet && fragmentMap\n            ? getTypenameFromResult(object, selectionSet, fragmentMap)\n            : object.__typename;\n        var context = {\n            typename: typename,\n            selectionSet: selectionSet,\n            fragmentMap: fragmentMap,\n            policies: this,\n        };\n        var id;\n        var policy = this.getTypePolicy(typename, false);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (Array.isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id && String(id);\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var existing = _this.getTypePolicy(typename, true);\n            var incoming = typePolicies[typename];\n            var keyFields = incoming.keyFields, fields = incoming.fields;\n            if (incoming.queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (incoming.mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (incoming.subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            existing.keyFn =\n                keyFields === false ? nullKeyFieldsFn :\n                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                        typeof keyFields === \"function\" ? keyFields : void 0;\n            if (fields) {\n                Object.keys(fields).forEach(function (fieldName) {\n                    var existing = _this.getFieldPolicy(typename, fieldName, true);\n                    var incoming = fields[fieldName];\n                    if (typeof incoming === \"function\") {\n                        existing.read = incoming;\n                    }\n                    else {\n                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                        existing.keyFn =\n                            keyArgs === false ? simpleKeyArgsFn :\n                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                    typeof keyArgs === \"function\" ? keyArgs :\n                                        existing.keyFn;\n                        if (typeof read === \"function\")\n                            existing.read = read;\n                        if (typeof merge === \"function\")\n                            existing.merge = merge;\n                    }\n                    if (existing.read && existing.merge) {\n                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                    }\n                });\n            }\n        });\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            var subtypeSet = _this.getSubtypeSet(supertype, true);\n            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n        if (typename) {\n            return this.typePolicies[typename] || (createIfMissing && (this.typePolicies[typename] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n        var policy = this.getTypePolicy(supertype, createIfMissing);\n        if (policy) {\n            return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n        }\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        var typePolicy = this.getTypePolicy(typename, createIfMissing);\n        if (typePolicy) {\n            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));\n            if (fieldPolicies) {\n                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n            }\n        }\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes) {\n            var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var subtypes = workQueue_1[i];\n                if (subtypes) {\n                    if (subtypes.has(typename))\n                        return true;\n                    subtypes.forEach(function (subtype) {\n                        var subsubtypes = _this.getSubtypeSet(subtype, false);\n                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n                            workQueue_1.push(subsubtypes);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.getStoreFieldName = function (typename, field, variables) {\n        var fieldName = field.name.value;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var args = argumentsObjectFromField(field, variables);\n            var context = { typename: typename, fieldName: fieldName, field: field, variables: variables, policies: this };\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (Array.isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = storeKeyNameFromField(field, variables);\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (objectOrReference, nameOrField, context, typename) {\n        if (typename === void 0) { typename = context.getFieldValue(objectOrReference, \"__typename\"); }\n        invariant(objectOrReference, \"Must provide an object or Reference when calling Policies#readField\");\n        var policies = this;\n        var storeFieldName = typeof nameOrField === \"string\" ? nameOrField\n            : policies.getStoreFieldName(typename, nameOrField, context.variables);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.getFieldValue(objectOrReference, storeFieldName);\n        var policy = policies.getFieldPolicy(typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var storage = policies.storageTrie.lookup(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName);\n            return read(existing, makeFieldFunctionOptions(policies, typename, objectOrReference, nameOrField, storage, context));\n        }\n        return existing;\n    };\n    Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.merge);\n    };\n    Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n        var policies = this;\n        if (isFieldValueToBeMerged(incoming)) {\n            var field = incoming.__field;\n            var fieldName = field.name.value;\n            var merge = policies.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n            var storage = storageKeys\n                ? policies.storageTrie.lookupArray(storageKeys)\n                : null;\n            incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(policies, incoming.__typename, null, field, storage, context));\n        }\n        if (incoming && typeof incoming === \"object\") {\n            if (isReference(incoming)) {\n                return incoming;\n            }\n            if (Array.isArray(incoming)) {\n                return incoming.map(function (item) { return policies.applyMerges(void 0, item, context); });\n            }\n            var e_1 = existing;\n            var i_1 = incoming;\n            var firstStorageKey_1 = isReference(e_1)\n                ? e_1.__ref\n                : typeof e_1 === \"object\" && e_1;\n            Object.keys(i_1).forEach(function (storeFieldName) {\n                i_1[storeFieldName] = policies.applyMerges(context.getFieldValue(e_1, storeFieldName), i_1[storeFieldName], context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n            });\n        }\n        return incoming;\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, typename, objectOrReference, nameOrField, storage, context) {\n    var toReference = context.toReference, getFieldValue = context.getFieldValue, variables = context.variables;\n    var storeFieldName = typeof nameOrField === \"string\" ? nameOrField :\n        policies.getStoreFieldName(typename, nameOrField, variables);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    return {\n        args: typeof nameOrField === \"string\" ? null :\n            argumentsObjectFromField(nameOrField, variables),\n        field: typeof nameOrField === \"string\" ? null : nameOrField,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        policies: policies,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        readField: function (nameOrField, foreignObjOrRef) {\n            return policies.readField(foreignObjOrRef || objectOrReference, nameOrField, context);\n        },\n        mergeObjects: function (existing, incoming) {\n            if (Array.isArray(existing) || Array.isArray(incoming)) {\n                throw new InvariantError(\"Cannot automatically merge arrays\");\n            }\n            if (existing && typeof existing === \"object\" &&\n                incoming && typeof incoming === \"object\") {\n                var eType = getFieldValue(existing, \"__typename\");\n                var iType = getFieldValue(incoming, \"__typename\");\n                var typesDiffer = eType && iType && eType !== iType;\n                var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n                if (typesDiffer ||\n                    !canBeMerged(existing) ||\n                    !canBeMerged(applied)) {\n                    return applied;\n                }\n                return __assign(__assign({}, existing), applied);\n            }\n            return incoming;\n        }\n    };\n}\nfunction canBeMerged(obj) {\n    return !!(obj &&\n        typeof obj === \"object\" &&\n        !isReference(obj) &&\n        !Array.isArray(obj));\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n    return function (args, context) {\n        var field = context.field;\n        var fieldName = field.name.value;\n        return args ? fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : fieldName;\n    };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var trie = new KeyTrie(canUseWeakMap);\n    return function (object, context) {\n        var aliasMap;\n        if (context.selectionSet && context.fragmentMap) {\n            var info = trie.lookupArray([\n                context.selectionSet,\n                context.fragmentMap,\n            ]);\n            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n        }\n        var keyObject = context.keyObject =\n            computeKeyObject(object, specifier, aliasMap);\n        return context.typename + \":\" + JSON.stringify(keyObject);\n    };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n    var map = Object.create(null);\n    var workQueue = new Set([selectionSet]);\n    workQueue.forEach(function (selectionSet) {\n        selectionSet.selections.forEach(function (selection) {\n            if (isField(selection)) {\n                if (selection.alias) {\n                    var responseKey = selection.alias.value;\n                    var storeKey = selection.name.value;\n                    if (storeKey !== responseKey) {\n                        var aliases = map.aliases || (map.aliases = Object.create(null));\n                        aliases[storeKey] = responseKey;\n                    }\n                }\n                if (selection.selectionSet) {\n                    var subsets = map.subsets || (map.subsets = Object.create(null));\n                    subsets[selection.name.value] =\n                        makeAliasMap(selection.selectionSet, fragmentMap);\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, fragmentMap);\n                if (fragment) {\n                    workQueue.add(fragment.selectionSet);\n                }\n            }\n        });\n    });\n    return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n    var keyObj = Object.create(null);\n    var prevKey;\n    specifier.forEach(function (s) {\n        if (Array.isArray(s)) {\n            if (typeof prevKey === \"string\") {\n                var subsets = aliasMap && aliasMap.subsets;\n                var subset = subsets && subsets[prevKey];\n                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n            }\n        }\n        else {\n            var aliases = aliasMap && aliasMap.aliases;\n            var responseName = aliases && aliases[s] || s;\n            invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n            keyObj[prevKey = s] = response[responseName];\n        }\n    });\n    return keyObj;\n}\n//# sourceMappingURL=policies.js.map"]},"metadata":{},"sourceType":"module"}